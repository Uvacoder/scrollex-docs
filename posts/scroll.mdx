import { Wrap, Box } from "@chakra-ui/react";
import InlineCode from "../components/InlineCode";
import FileAction from "../components/FileAction";
import SandpackCodeBlock from "../components/SandpackCodeBlock";
import CodeSection, { CodeSectionProvider } from "../components/CodeSection";
import * as files from "../components/files";

<CodeSectionProvider>
<CodeSection>

# Guide

Scrollex let's you create beautiful scroll experiences with minimal code.

</CodeSection>
<CodeSection files={files.base}>

First you'll want to install `scrollex` along with `framer-motion`.

```html
npm install --save scrollex framer-motion
```

In our app we'll need to add a `Scroll.Container` which will hold all of our scrollable content.

In many cases we'll want the container to take up the full size of the viewport however it can be any size.

```jsx
<Scroll.Container scrollAxis="y" className="h-screen">
  {/* content... */}
</Scroll.Container>
```

</CodeSection>
<CodeSection files={files.sectionOne}>

Next we'll partition our content in to different sections.

```jsx
<Scroll.Container scrollAxis="y" className="h-screen">
  <Scroll.Section className="h-full children-center">
    <h1>Page One</h1>
  </Scroll.Section>
  <Scroll.Section className="h-full children-center">
    <h1>Page Two</h1>
  </Scroll.Section>
  <Scroll.Section className="h-full children-center">
    <h1>Page Three</h1>
  </Scroll.Section>
</Scroll.Container>
```

This will give us access to important keyframes as we're scrolling through the container's content.

For example we might want to define some condition to be true when the top of a section intersects the top of the container.

At this point, you'll notice we just have a static page with no motion. In general we recommend first building the static layout, and then adding motion where you see fit.

So let's go ahead and add some motion to the example.

</CodeSection>
<CodeSection files={files.sectionTwo}>

To do this we'll use the `Scroll.Item` component and pass it some keyframes.

```jsx
const keyframes = {
  heading: {
    0: {
      rotateZ: "0deg",
    },
    200: {
      rotateZ: "180deg",
    },
  },
};

export default function App() {
  return (
    <Scroll.Container scrollAxis="y" className="h-screen">
      <Scroll.Section className="h-full children-center">
        <Scroll.Item keyframes={keyframes.heading}>
          <h1>Page One</h1>
        </Scroll.Item>
      </Scroll.Section>
      <Scroll.Section className="h-full children-center">
        <Scroll.Item keyframes={keyframes.heading}>
          <h1>Page Two</h1>
        </Scroll.Item>
      </Scroll.Section>
      <Scroll.Section className="h-full children-center">
        <Scroll.Item keyframes={keyframes.heading}>
          <h1>Page Three</h1>
        </Scroll.Item>
      </Scroll.Section>
    </Scroll.Container>
  );
}
```

These keyframes define how an element should look as the user scrolls through the content.

The code above dictates that when the user has scrolled down an amount of 200 pixels, then any heading should have a rotation of 180 degrees.

However it also dictates that before the user has scrolled at all, headings should have no rotation applied.

So then you might be wondering what will the rotation be when the user has scrolled down 100 pixels from the top.

Well it turns out it will be 90 degrees because scrollex uses linear interpolation to transition between keyframes.

</CodeSection>

<CodeSection files={files.sectionThree}>

Hardcoding in pixel offsets is not particularly wise or advisable, and for that reason scrollex provides some keyframe helpers.

```jsx
const keyframes = {
  heading: ({ section }) => ({
    [section.topAt("container-top")]: {
      rotateZ: "0deg",
    },
    [section.bottomAt("container-top")]: {
      rotateZ: "180deg",
    },
  }),
};

export default function App() {
  return (
    <Scroll.Container scrollAxis="y" className="h-screen">
      <Scroll.Section className="h-full children-center">
        <Scroll.Item keyframes={keyframes.heading}>
          <h1>Page One</h1>
        </Scroll.Item>
      </Scroll.Section>
      <Scroll.Section className="h-full children-center">
        <Scroll.Item keyframes={keyframes.heading}>
          <h1>Page Two</h1>
        </Scroll.Item>
      </Scroll.Section>
      <Scroll.Section className="h-full children-center">
        <Scroll.Item keyframes={keyframes.heading}>
          <h1>Page Three</h1>
        </Scroll.Item>
      </Scroll.Section>
    </Scroll.Container>
  );
}
```

Now each heading will rotate only when we scroll down to its containing section.

Here `section.topAt("container-top")` will return the number of pixels the user has to scroll for the top edge of the section to intersect the top edge of the container.

Likewise `section.bottomAt("container-top")` will return the number of pixels the user has to scroll for the bottom edge of the section to intersect the top edge of the container.

But how do we know which section we're dealing with?

Well `Scroll.Item` can only be used within `Scroll.Section`, so the keyframes function passed to a `Scroll.Item` will always reference the item's containing section.

The cool thing about this is that scrollex is tracking the section bounds internally and if the section's size/position happen to change, scrollex will automatically recalculate our keyframes.

</CodeSection>
</CodeSectionProvider>
