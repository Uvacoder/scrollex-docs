import { Wrap, Box } from "@chakra-ui/react";
import InlineCode from "../components/InlineCode";
import FileAction from "../components/FileAction";
import CodeBlock from "../components/CodeBlock";
import CodeSection, { CodeSectionProvider } from "../components/CodeSection";
import * as files from "../components/files";

<CodeSectionProvider>
<CodeSection>

# Guide

Scrollex let's you create beautiful scroll experiences with minimal code.

</CodeSection>
<CodeSection files={files.base}>

First you'll want to install scrollex along with `framer-motion`.

```html
npm install --save scrollex framer-motion
```

In our app we'll add a `Scroll.Container` which will hold all of our scrollable content.
In many cases we'll want the container to take up the full size of the viewport however it can be any size.

```jsx
<Scroll.Container scrollAxis="y" className="h-screen">
  {/* content... */}
</Scroll.Container>
```

</CodeSection>
<CodeSection files={files.sectionOne}>

Next we'll partition our content in to different sections.

```jsx
<Scroll.Container scrollAxis="y" className="h-screen">
  <Scroll.Section className="h-full children-center">
    <h1>Page One</h1>
  </Scroll.Section>
  <Scroll.Section className="h-full children-center">
    <h1>Page Two</h1>
  </Scroll.Section>
  <Scroll.Section className="h-full children-center">
    <h1>Page Three</h1>
  </Scroll.Section>
</Scroll.Container>
```

This will give us access to important keyframes as we're scrolling through the container's content.

For example we might want to define some condition to be true when the top of a section intersects the top of the container.

At this point, you'll notice we just have a static page with no motion. In general we recommend first building the static layout, and then adding motion where you see fit.

So let's go ahead and add some motion to the example.

</CodeSection>
<CodeSection files={files.sectionTwo}>

To do this we'll use the `Scroll.Item` component and pass it some keyframes.

```jsx
const keyframes = {
  banner: {
    0: {
      rotateZ: "0deg",
    },
    200: {
      rotateZ: "180deg",
    },
  },
};

<Scroll.Container scrollAxis="y" className="h-screen">
  <Scroll.Section className="h-full children-center">
    <Scroll.Item keyframes={keyframes.banner}>
      <h1>Page One</h1>
    </Scroll.Item>
  </Scroll.Section>
  <Scroll.Section className="h-full children-center">
    <h1>Page Two</h1>
  </Scroll.Section>
  <Scroll.Section className="h-full children-center">
    <h1>Page Three</h1>
  </Scroll.Section>
</Scroll.Container>;
```

These keyframes define how an element should look as the user scrolls through the content.

The code above dictates that when the user has scrolled down an amount of 200 pixels, then the banner should have a rotation of 180 degrees.

However it also dictates that before the user has scrolled at all, the banner should have no rotation applied.

So then you might be wondering what the rotation will be when the user has scrolled down 100 pixels from the top.

Well it turns out it will be 90 degrees because scrollex uses linear interpolation to transition between keyframes.

</CodeSection>
</CodeSectionProvider>
